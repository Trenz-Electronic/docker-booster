#!/bin/sh
#
# docker-booster - Docker Container Manager with Auto-build
# https://github.com/Trenz-Electronic/docker-booster
#
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Trenz Electronic GmbH
#
# ---
#
# build-and-run - Docker Container Manager with Auto-build
#
# A generalized script for running Docker containers with automatic rebuilding
# when images don't exist. Handles cross-platform builds, user mapping, and
# volume mounting for seamless development workflows.
#
# FEATURES:
# - Automatic Docker image building when missing
# - Cross-platform support via Dockerfile platform directives
# - User/group mapping to avoid permission issues
# - Automatic volume mounting based on working directory location
# - TTY detection for interactive sessions
#
# SETUP:
# 1. Create a directory with your desired container name:
#    mkdir my-container
#
# 2. Add a Dockerfile to this directory:
#    echo 'FROM ubuntu:20.04' > my-container/Dockerfile
#
# 3. Create a symlink to this script in the container directory:
#    cd my-container && ln -s ../build-and-run run
#
# 4. (Optional) Add platform directive to Dockerfile for cross-platform builds:
#    # platform: arm64
#    FROM ubuntu:20.04
#
# USAGE EXAMPLES:
#   ./my-container/run bash                    # Start interactive bash
#   ./my-container/run make                    # Run make command
#   ./my-container/run python3 script.py      # Run Python script
#
# PLATFORM SUPPORT:
# Add a platform comment in the first 10 lines of your Dockerfile:
#   # platform: arm64     # For ARM64/aarch64
#   # platform: amd64     # For x86_64
#
# If no platform directive is found, Docker will use the host platform.
#
# VOLUME MOUNTING:
# - $HOME/* paths: Mount $HOME only
# - /mnt/* paths: Mount /mnt + $HOME
# - Other paths: Mount current directory + $HOME
#
# TECHNICAL NOTES:
# - Creates temporary user inside container matching host UID/GID
# - Grants sudo access to created user
# - Preserves working directory inside container
# - Auto-detects TTY for interactive sessions

set -e

myname=$(basename $0)

# Are we the user command to be executed?
if [ x"${myname}" = x"user-command" ]; then
  # Run the given command in the container.

  # Argument checks.
  if [ $# -lt 6 ]; then
    >&2 echo "Missing command-line parameters."
    >&2 echo "Usage:  container USER USERID GROUPID GROUPNAME HOME COMMAND [PARAMETERS]"
    exit 2
  fi
  USER=$1
  shift || exit $?
  USERID=$1
  shift || exit $?
  GROUPID=$1
  shift || exit $?
  GROUPNAME=$1
  shift || exit $?
  HOME=$1
  shift || exit $?

  # Add ourselves to the system.
  if ! grep -q ^$USER: /etc/passwd; then
    echo "$USER:*:$USERID:$GROUPID:Docker runner:$HOME:/bin/bash" >> /etc/passwd
    echo "$USER ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers.d/10-docker-users
  fi

  # Create group with host group name, handling conflicts
  if grep -q "^$GROUPNAME:" /etc/group; then
    # Group name exists, check if GID matches
    EXISTING_GID=$(grep "^$GROUPNAME:" /etc/group | cut -d: -f3)
    if [ "$EXISTING_GID" != "$GROUPID" ]; then
      # GID conflict, use alternate name
      GROUPNAME="${GROUPNAME}_$GROUPID"
      if ! grep -q "^$GROUPNAME:" /etc/group; then
        echo "$GROUPNAME::$GROUPID::" >> /etc/group
      fi
    fi
    # Else: group exists with same GID, use it as-is
  else
    # Group doesn't exist, create it
    echo "$GROUPNAME::$GROUPID::" >> /etc/group
  fi

  # Extract #copy.home: files if provided
  if [ -f /tmp/home-files.tar.gz ]; then
    cd "$HOME"
    tar xzf /tmp/home-files.tar.gz 2>/dev/null || true
    cd - >/dev/null
  fi

  # Execute the command as the requested user
  # Use "$@" instead of $* to preserve argument boundaries
  # Build environment preservation arguments for sudo
  ENV_ARGS=""
  if [ -n "$DOCKER_PRESERVE_ENV" ]; then
    # Parse comma-separated list and build "VAR=$VAR" arguments
    OLD_IFS="$IFS"
    IFS=','
    for var in $DOCKER_PRESERVE_ENV; do
      eval "val=\$$var"
      ENV_ARGS="$ENV_ARGS $var=$val"
    done
    IFS="$OLD_IFS"
  fi
  exec sudo -u $USER env $ENV_ARGS "$@"
  >&2 echo "Exec failed somehow. Error code: $?"
  exit 3
fi

real_self=$(realpath --no-symlinks $0)
dir=$(dirname ${real_self})
tag=$(basename $dir)

# Parse command-line options meant for docker
CMDLINE_ENV_ARGS=""
CMDLINE_ENV_VARS=""
CMDLINE_DOCKER_ARGS=""
while [ $# -gt 0 ]; do
  case "$1" in
    -e)
      # -e VAR=val
      shift
      CMDLINE_ENV_ARGS="$CMDLINE_ENV_ARGS -e $1"
      CMDLINE_ENV_VARS="$CMDLINE_ENV_VARS,$(echo "$1" | cut -d= -f1)"
      shift
      ;;
    --env=*)
      # --env=VAR=val
      val="${1#--env=}"
      CMDLINE_ENV_ARGS="$CMDLINE_ENV_ARGS -e $val"
      CMDLINE_ENV_VARS="$CMDLINE_ENV_VARS,$(echo "$val" | cut -d= -f1)"
      shift
      ;;
    --env)
      # --env VAR=val
      shift
      CMDLINE_ENV_ARGS="$CMDLINE_ENV_ARGS -e $1"
      CMDLINE_ENV_VARS="$CMDLINE_ENV_VARS,$(echo "$1" | cut -d= -f1)"
      shift
      ;;
    -v|--volume)
      # -v /host:/container or --volume /host:/container
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -v $1"
      shift
      ;;
    --volume=*)
      # --volume=/host:/container
      val="${1#--volume=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -v $val"
      shift
      ;;
    -p|--publish)
      # -p 8080:80 or --publish 8080:80
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -p $1"
      shift
      ;;
    --publish=*)
      # --publish=8080:80
      val="${1#--publish=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -p $val"
      shift
      ;;
    -w|--workdir)
      # -w /path or --workdir /path
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -w $1"
      shift
      ;;
    --workdir=*)
      # --workdir=/path
      val="${1#--workdir=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS -w $val"
      shift
      ;;
    --network|--net)
      # --network host or --net host
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --network $1"
      shift
      ;;
    --network=*|--net=*)
      # --network=host
      val="${1#--network=}"
      val="${val#--net=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --network $val"
      shift
      ;;
    --device)
      # --device /dev/ttyUSB0
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --device $1"
      shift
      ;;
    --device=*)
      # --device=/dev/ttyUSB0
      val="${1#--device=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --device $val"
      shift
      ;;
    --cpus)
      # --cpus 2
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --cpus $1"
      shift
      ;;
    --cpus=*)
      # --cpus=2
      val="${1#--cpus=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --cpus $val"
      shift
      ;;
    -m|--memory)
      # -m 1g or --memory 1g
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --memory $1"
      shift
      ;;
    --memory=*)
      # --memory=1g
      val="${1#--memory=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --memory $val"
      shift
      ;;
    --gpus)
      # --gpus all
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --gpus $1"
      shift
      ;;
    --gpus=*)
      # --gpus=all
      val="${1#--gpus=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --gpus $val"
      shift
      ;;
    --name)
      # --name mycontainer
      shift
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --name $1"
      shift
      ;;
    --name=*)
      # --name=mycontainer
      val="${1#--name=}"
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS --name $val"
      shift
      ;;
    --privileged|--read-only)
      # Boolean flags
      CMDLINE_DOCKER_ARGS="$CMDLINE_DOCKER_ARGS $1"
      shift
      ;;
    -*)
      # Unknown option - stop parsing, assume it's part of the command
      break
      ;;
    *)
      # Not an option - this is the command
      break
      ;;
  esac
done
# Remove leading comma from CMDLINE_ENV_VARS
CMDLINE_ENV_VARS=$(echo "$CMDLINE_ENV_VARS" | sed 's/^,//')

# Parse #mount: and #copy.home: directives from Dockerfile
MOUNT_KEYWORDS=""
COPY_HOME_FILES=""
if [ -f "$dir/Dockerfile" ]; then
  # Parse #mount: directives (first 20 lines, multiple directives allowed)
  MOUNT_LINES=$(head -n 20 "$dir/Dockerfile" | grep -E '^#\s*mount:\s*' || true)
  if [ -n "$MOUNT_LINES" ]; then
    MOUNT_KEYWORDS=$(echo "$MOUNT_LINES" | sed -E 's/^#\s*mount:\s*//' | tr '\n' ' ')
  fi

  # Parse #copy.home: directives (first 20 lines, multiple directives allowed)
  COPY_HOME_LINES=$(head -n 20 "$dir/Dockerfile" | grep -E '^#\s*copy\.home:\s*' || true)
  if [ -n "$COPY_HOME_LINES" ]; then
    COPY_HOME_FILES=$(echo "$COPY_HOME_LINES" | sed -E 's/^#\s*copy\.home:\s*//' | tr '\n' ' ')
  fi
fi

# Function to find .git directory by traversing up from current directory
find_git_root() {
  search_dir="$1"
  while [ "$search_dir" != "/" ]; do
    if [ -d "$search_dir/.git" ]; then
      echo "$search_dir"
      return 0
    fi
    search_dir=$(dirname "$search_dir")
  done
  return 1
}

# Determine mount directory based on #mount: directives or default behavior
MDIR=""

if [ -n "$MOUNT_KEYWORDS" ]; then
  # Process #mount: directives - FIRST found wins
  MOUNT_RESOLVED=0
  for keyword in $MOUNT_KEYWORDS; do
    case "$keyword" in
      home)
        if [ -d "$HOME" ]; then
          MDIR="$HOME"
          MOUNT_RESOLVED=1
          >&2 echo "Mount directive: Using home directory ($HOME)"
          break
        else
          >&2 echo "WARNING: #mount: home - directory not found, trying next"
        fi
        ;;
      pwd)
        if [ -d "$PWD" ]; then
          MDIR="$PWD"
          MOUNT_RESOLVED=1
          >&2 echo "Mount directive: Using current directory ($PWD)"
          break
        else
          >&2 echo "WARNING: #mount: pwd - directory not found, trying next"
        fi
        ;;
      .git)
        GIT_ROOT=$(find_git_root "$PWD")
        if [ -n "$GIT_ROOT" ]; then
          MDIR="$GIT_ROOT"
          MOUNT_RESOLVED=1
          >&2 echo "Mount directive: Using git root directory ($GIT_ROOT)"
          break
        else
          >&2 echo "WARNING: #mount: .git - git repository not found, trying next"
        fi
        ;;
      *)
        >&2 echo "WARNING: #mount: unknown keyword '$keyword', ignoring"
        ;;
    esac
  done

  if [ "$MOUNT_RESOLVED" -eq 0 ]; then
    >&2 echo "ERROR: All #mount: directives failed to resolve a directory"
    exit 1
  fi
else
  # Default behavior (no #mount: directive): Try .git first, fall back to pwd
  # This provides secure-by-default behavior for git repositories
  GIT_ROOT=$(find_git_root "$PWD")
  if [ -n "$GIT_ROOT" ]; then
    MDIR="$GIT_ROOT"
  else
    MDIR="$PWD"
  fi
fi

# Optimized inspect: get architecture, creation time, and context hash in one call
INSPECT_DATA=$(docker inspect --format='{{.Architecture}}|{{.Created}}|{{index .Config.Labels "docker-booster.context-hash"}}' ${tag} 2>/dev/null) || true

if [ -n "$INSPECT_DATA" ]; then
  IMGARCH=$(echo "$INSPECT_DATA" | cut -d'|' -f1)
  IMG_CREATED=$(echo "$INSPECT_DATA" | cut -d'|' -f2)
  IMG_HASH=$(echo "$INSPECT_DATA" | cut -d'|' -f3)
else
  IMGARCH=""
  IMG_CREATED=""
  IMG_HASH=""
fi

# Calculate current context hash for change detection
CONTEXT_HASH=""
NEED_REBUILD=0

if [ -d "$dir" ]; then
  # Hash all files in build context for deterministic fingerprint
  CONTEXT_HASH=$(find "$dir" -type f ! -path '*/.git/*' ! -name '*.swp' 2>/dev/null | sort | xargs cat 2>/dev/null | sha256sum | cut -d' ' -f1)
fi

# Check if rebuild is needed
if [ x"${IMGARCH}" = x"" ]; then
  >&2 echo "Docker image ${tag} not found, rebuilding..."
  NEED_REBUILD=1
elif [ -n "$CONTEXT_HASH" ] && [ "$IMG_HASH" != "$CONTEXT_HASH" ]; then
  if [ -z "$IMG_HASH" ]; then
    # Image exists without hash label - only rebuild if Dockerfile exists
    if [ -f "$dir/Dockerfile" ]; then
      >&2 echo "Image ${tag} exists but lacks hash label, rebuilding to enable change detection..."
      NEED_REBUILD=1
    else
      >&2 echo "Image ${tag} exists (no Dockerfile found, skipping hash check)"
      NEED_REBUILD=0
    fi
  else
    >&2 echo "Context changes detected, rebuilding image ${tag}..."
    NEED_REBUILD=1
  fi
elif [ -n "$IMG_HASH" ] && [ "$IMG_HASH" = "$CONTEXT_HASH" ]; then
  SHORT_HASH=$(echo "$CONTEXT_HASH" | cut -c1-12)
  >&2 echo "Image ${tag} is up-to-date (context hash: ${SHORT_HASH})"
  NEED_REBUILD=0
fi

if [ "$NEED_REBUILD" -eq 1 ]; then
  # Image needs rebuild

  # Parse platform tag from Dockerfile
  BUILD_PLATFORM=""
  HTTP_SERVERS=""
  HTTP_SERVER_PIDS=""
  BUILD_ARGS=""

  if [ -f "$dir/Dockerfile" ]; then
    PLATFORM_LINE=$(head -n 10 "$dir/Dockerfile" | grep -E '^#\s*platform:\s*' | head -n 1)
    if [ -n "$PLATFORM_LINE" ]; then
      BUILD_PLATFORM=$(echo "$PLATFORM_LINE" | sed -E 's/^#\s*platform:\s*([^\s]+).*/\1/')
      >&2 echo "Found platform tag in Dockerfile: ${BUILD_PLATFORM}"
    fi

    # Check if Dockerfile uses RUN --mount syntax (requires BuildKit)
    if grep -q '^RUN --mount' "$dir/Dockerfile"; then
      >&2 echo "Dockerfile uses BuildKit mount syntax, enabling DOCKER_BUILDKIT=1"
      export DOCKER_BUILDKIT=1
    fi

    # Parse http.static directives and start HTTP servers
    HTTP_STATIC_LINES=$(head -n 20 "$dir/Dockerfile" | grep -E '^#\s*http\.static:\s*' || true)
    if [ -n "$HTTP_STATIC_LINES" ]; then
      while IFS= read -r http_line; do
        # Parse: #http.static: KEY=/path/to/dir
        HTTP_SPEC=$(echo "$http_line" | sed -E 's/^#\s*http\.static:\s*//')
        HTTP_KEY=$(echo "$HTTP_SPEC" | cut -d= -f1)
        HTTP_PATH=$(echo "$HTTP_SPEC" | cut -d= -f2-)

        if [ ! -d "$HTTP_PATH" ]; then
          >&2 echo "ERROR: http.static path does not exist: $HTTP_PATH"
          exit 1
        fi

        # Start HTTP server on random port using Python script
        HTTP_SERVER_SCRIPT=$(mktemp)
        HTTP_PORT_FILE="/tmp/http-server-port-$$.txt"
        cat > "$HTTP_SERVER_SCRIPT" <<PYEOF
import http.server
import socketserver
import sys
import os

serve_dir = sys.argv[1]
port_file = sys.argv[2]

os.chdir(serve_dir)
Handler = http.server.SimpleHTTPRequestHandler
with socketserver.TCPServer(("", 0), Handler) as httpd:
    port = httpd.server_address[1]
    with open(port_file, 'w') as f:
        f.write(str(port))
    httpd.serve_forever()
PYEOF

        cd "$HTTP_PATH"
        python3 "$HTTP_SERVER_SCRIPT" "$HTTP_PATH" "$HTTP_PORT_FILE" 2>/dev/null &
        SERVER_PID=$!
        HTTP_SERVER_PIDS="$HTTP_SERVER_PIDS $SERVER_PID"

        # Wait for server to start and get port
        SERVER_PORT=""
        for i in 1 2 3 4 5 6 7 8 9 10; do
          if [ -f "$HTTP_PORT_FILE" ]; then
            SERVER_PORT=$(cat "$HTTP_PORT_FILE")
            break
          fi
          sleep 0.5
        done

        if [ -z "$SERVER_PORT" ]; then
          >&2 echo "ERROR: Failed to start HTTP server for $HTTP_KEY"
          kill $SERVER_PID 2>/dev/null || true
          rm -f "$HTTP_SERVER_SCRIPT"
          exit 1
        fi

        # On Linux, use the Docker bridge gateway IP instead of host.docker.internal
        HOST_IP=$(ip route | awk '/docker0/ {print $9}' | head -n1)
        if [ -z "$HOST_IP" ]; then
          # Fallback to getting the default route IP
          HOST_IP=$(ip route get 1 | awk '{print $7;exit}')
        fi
        SERVER_URL="http://${HOST_IP}:${SERVER_PORT}"
        BUILD_ARGS="$BUILD_ARGS --build-arg HTTP_${HTTP_KEY}=${SERVER_URL}"

        >&2 echo "Started HTTP server for ${HTTP_KEY}: ${SERVER_URL} (PID: ${SERVER_PID})"
        cd - >/dev/null
      done <<EOF
$HTTP_STATIC_LINES
EOF
    fi

    # Cleanup function for HTTP servers
    cleanup_http_servers() {
      if [ -n "$HTTP_SERVER_PIDS" ]; then
        >&2 echo "Stopping HTTP servers..."
        for pid in $HTTP_SERVER_PIDS; do
          kill $pid 2>/dev/null || true
        done
        rm -f /tmp/http-server-port-$$.txt
        rm -f /tmp/http-server-*.py 2>/dev/null || true
      fi
    }
    trap cleanup_http_servers EXIT INT TERM

    # Build docker image with collected options
    BUILD_CMD="docker build -t $tag --progress=plain"
    if [ -n "$BUILD_PLATFORM" ]; then
      BUILD_CMD="$BUILD_CMD --platform=${BUILD_PLATFORM}"
    fi
    if [ -n "$BUILD_ARGS" ]; then
      BUILD_CMD="$BUILD_CMD $BUILD_ARGS"
    fi
    # Add context hash label for change detection
    if [ -n "$CONTEXT_HASH" ]; then
      BUILD_CMD="$BUILD_CMD --label docker-booster.context-hash=${CONTEXT_HASH}"
    fi
    BUILD_CMD="$BUILD_CMD $dir"

    >&2 echo "Running: $BUILD_CMD"
    eval $BUILD_CMD
    BUILD_RESULT=$?

    cleanup_http_servers
    trap - EXIT INT TERM

    if [ $BUILD_RESULT -ne 0 ]; then
      exit $BUILD_RESULT
    fi
  else
    docker build -t $tag --progress=plain $dir
  fi

  # Update architecture after build (reuse optimized inspect format)
  INSPECT_DATA=$(docker inspect --format='{{.Architecture}}|{{.Created}}|{{index .Config.Labels "docker-booster.context-hash"}}' ${tag} 2>/dev/null) || true
  if [ -n "$INSPECT_DATA" ]; then
    IMGARCH=$(echo "$INSPECT_DATA" | cut -d'|' -f1)
  fi
fi

# Check if stdin is a TTY using POSIX test
TFLAG=""
if [ -t 0 ]; then
  TFLAG="-t"
fi

# Set platform argument only if IMGARCH is not empty
PLATFORM_ARG=""
if [ -n "$IMGARCH" ]; then
  PLATFORM_ARG="--platform ${IMGARCH}"
fi

# Handle #copy.home: files - create tar archive
COPY_HOME_VARG=""
COPY_HOME_TAR=""
if [ -n "$COPY_HOME_FILES" ]; then
  COPY_HOME_TAR="/tmp/docker-booster-home-files-$$.tar.gz"
  cd "$HOME"

  # Try to create tar, check for missing files
  if tar czf "$COPY_HOME_TAR" $COPY_HOME_FILES 2>/dev/null; then
    COPY_HOME_VARG="-v $COPY_HOME_TAR:/tmp/home-files.tar.gz:ro"
    >&2 echo "Collected home files for container: $COPY_HOME_FILES"
  else
    # Tar failed, list missing files
    >&2 echo "ERROR: Failed to collect files from \$HOME. Missing files:"
    for f in $COPY_HOME_FILES; do
      if [ ! -e "$HOME/$f" ]; then
        >&2 echo "  $HOME/$f"
      fi
    done
    exit 1
  fi
  cd - >/dev/null
fi

# Parse #option: directives for additional docker run options
DOCKER_OPTIONS=""
OPTION_ENV_VARS=""
if [ -f "$dir/Dockerfile" ]; then
  OPTION_LINES=$(head -n 20 "$dir/Dockerfile" | grep -E '^#\s*option:\s*' || true)
  if [ -n "$OPTION_LINES" ]; then
    DOCKER_OPTIONS=$(echo "$OPTION_LINES" | sed -E 's/^#\s*option:\s*//' | tr '\n' ' ')
    # Extract env var names from -e options in DOCKER_OPTIONS
    OPTION_ENV_VARS=$(echo "$DOCKER_OPTIONS" | grep -oE '(-e|--env=?)[[:space:]]*[A-Za-z_][A-Za-z0-9_]*=' | sed -E 's/(-e|--env=?)[[:space:]]*//' | sed 's/=$//' | tr '\n' ',' | sed 's/,$//')
  fi
fi

# Auto-preserve ENV vars from Dockerfile across sudo
# Extract ENV var names after the last FROM line
PRESERVE_ENV_ARG=""
ENV_VARS=""
if [ -f "$dir/Dockerfile" ]; then
  # Get line number of last FROM, then extract ENV lines after it
  LAST_FROM=$(grep -n '^FROM' "$dir/Dockerfile" | tail -1 | cut -d: -f1)
  if [ -n "$LAST_FROM" ]; then
    # Extract ENV var names (handles both "ENV FOO=bar" and "ENV FOO bar" syntax)
    ENV_VARS=$(tail -n +$LAST_FROM "$dir/Dockerfile" | \
      grep -E '^\s*ENV\s+' | \
      sed -E 's/^\s*ENV\s+//' | \
      sed -E 's/^([A-Za-z_][A-Za-z0-9_]*)[= ].*/\1/' | \
      tr '\n' ',' | sed 's/,$//')
  fi
fi
# Combine Dockerfile ENV vars with command-line and #option: env vars
for extra_vars in "$CMDLINE_ENV_VARS" "$OPTION_ENV_VARS"; do
  if [ -n "$extra_vars" ]; then
    if [ -n "$ENV_VARS" ]; then
      ENV_VARS="$ENV_VARS,$extra_vars"
    else
      ENV_VARS="$extra_vars"
    fi
  fi
done
if [ -n "$ENV_VARS" ]; then
  PRESERVE_ENV_ARG="-e DOCKER_PRESERVE_ENV=$ENV_VARS"
fi

# Cleanup function for temporary tar file
cleanup_copy_home() {
  if [ -n "$COPY_HOME_TAR" ] && [ -f "$COPY_HOME_TAR" ]; then
    rm -f "$COPY_HOME_TAR"
  fi
}
trap cleanup_copy_home EXIT INT TERM

# Use "$@" instead of $* to preserve argument boundaries
exec docker run --rm -i $TFLAG \
  -v ${real_self}:/bin/user-command \
  -v $MDIR:$MDIR \
  $COPY_HOME_VARG \
  -w $PWD \
  --entrypoint /bin/sh \
  $PLATFORM_ARG \
  $PRESERVE_ENV_ARG \
  $CMDLINE_ENV_ARGS \
  $CMDLINE_DOCKER_ARGS \
  $DOCKER_OPTIONS \
  $tag \
  /bin/user-command $USER "$(id -u)" "$(id -g)" "$(id -gn)" $HOME "$@"

